## Anexo A - Instruções da Arquitetura

As instruções são classificadas de acordo com a sua estrutura ou de acordo com a sua função. No que se refere a estrutura, as instruções podem ser do tipo R, I, S, B, U ou J, como demonstrado na figura 30:

<table>
    <thead>
        <tr>
            <th style="text-align: center; white-space: nowrap;">Tipo</th>
            <th style="text-align: center; white-space: nowrap;">31 - 25</th>
            <th style="text-align: center; white-space: nowrap;">24 - 20</th>
            <th style="text-align: center; white-space: nowrap;">19 - 15</th>
            <th style="text-align: center; white-space: nowrap;">14 - 12</th>
            <th style="text-align: center; white-space: nowrap;">11 - 7</th>
            <th style="text-align: center; white-space: nowrap;">6 - 0</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td style="text-align: center;">
                R
            </td>
            <td style="text-align: center;">
                funct7
            </td>
            <td style="text-align: center;">
                rs2
            </td>
            <td style="text-align: center;">
                rs1
            </td>
            <td style="text-align: center;">
                funct3
            </td>
            <td style="text-align: center;">
                rd
            </td>
            <td style="text-align: center;">
                opcode
            </td>
        </tr>
        <tr>
            <td style="text-align: center;">
                I
            </td>
            <td style="text-align: center;"  colspan="2">
                imm[11:0]
            </td>
            <td style="text-align: center;">
                rs1
            </td>
            <td style="text-align: center;">
                funct3
            </td>
            <td style="text-align: center;">
                rd
            </td>
            <td style="text-align: center;">
                opcode
            </td>
        </tr>
        <tr>
            <td style="text-align: center;">
                S
            </td>
            <td style="text-align: center;">
                imm[11:5]
            </td>
            <td style="text-align: center;">
                rs2
            </td>
            <td style="text-align: center;">
                rs1
            </td>
            <td style="text-align: center;">
                funct3
            </td>
            <td style="text-align: center;">
                imm[4:0]
            </td>
            <td style="text-align: center;">
                opcode
            </td>
        </tr>
        <tr>
            <td style="text-align: center;">
                B
            </td>
            <td style="text-align: center;">
                imm[12|10:5]
            </td>
            <td style="text-align: center;">
                rs2
            </td>
            <td style="text-align: center;">
                rs1
            </td>
            <td style="text-align: center;">
                funct3
            </td>
            <td style="text-align: center;">
                imm[4:1|11]
            </td>
            <td style="text-align: center;">
                opcode
            </td>
        </tr>
        <tr>
            <td style="text-align: center;">
                U
            </td>
            <td style="text-align: center;" colspan="4">
                imm[31:12]
            </td>
            <td style="text-align: center;">
                rd
            </td>
            <td style="text-align: center;">
                opcode
            </td>
        </tr>
        <tr>
            <td style="text-align: center;">
                J
            </td>
            <td style="text-align: center;" colspan="4">
                imm[20|10:1|11|19:12]
            </td>
            <td style="text-align: center;">
                rd
            </td>
            <td style="text-align: center;">
                opcode
            </td>
        </tr>
    </tbody>
</table>

Instruções do tipo R são usadas para realizar operações entre registradores.

Instruções do tipo I são utilizadas para realizar operações em registradores com uso de valores imediatos.

Instruções do tipo S armazenam valores na memória.

Instruções do tipo B realizam desvios no programa dependendo do resultado da comparação de valores em dois registradores.

Instruções do tipo U são empregadas em operações que usam os 20 bits mais significativos da instrução como imediato, com os bits remanescentes sendo 0.

Apenas a instrução JAL (Jump and Link - Salto e Conexão) é do tipo J.

Por sua vez, a classificação das instruções, segundo sua funcionalidade, divide-as em grupos independentemente de sua estrutura. 

Esses grupos incluem:
- As instruções de construção, que criam valores em registradores;
- As instruções de deslocamento, que realizam operações de deslocamento de bits nos valores armazenados nos registradores;
- As instruções aritméticas, que efetuam operações matemáticas;
- As instruções lógicas, que são responsáveis por operações lógicas;
- As instruções de desvio, que alteram o fluxo de execução do programa com base em condições; 
- As instruções de salto, que permitem saltos para outras partes do programa; 
- As instruções de carregar, que carregam valores da memória para os registradores; 
- As instruções de armazenar, que guardam valores dos registradores na memória.

Seguem instruções, onde Base RV32I significa que elas pertencem ao conjunto base de instruções para inteiros de 32 bits, e Extensão M significa que elas pertencem à extensão de Multiplicação:

**Instruções de Construção**

LUI (Base RV32I)
- Load Upper Immediate (Carregar Imediato Superior).
- Carrega registradores com valores constantes de 32 bits. Ela guarda o valor imediato dos 20 bits mais significativos da instrução nos 20 bits mais significativos do registrador de destino (rd), preenchendo os 12 bits menos significativos com zero.

AUIPC (Base RV32I)
- Add Upper Immediate to Program Counter (Adiciona Imediato Superior ao Contador de Programa).
- Desloca o valor imediato da instrução, que consiste nos 20 bits mais significativos, 12 bits à esquerda, preenchendo os 12 bits menos significativos com zero, e o adiciona ao PC. O resultado é então escrito no registrador de destino (rd).

**Instruções de Deslocamento** 

SLL (Base RV32I)
- Shift Left Logical (Deslocamento Lógico à Esquerda).
- Desloca o valor guardado no registrador de origem primário (rs1) à esquerda pelo número de posições indicado pelos 5 bits menos significativos do valor guardado no registrador de origem secundário (rs2). Os bits remanescentes de rs2 são ignorados. Os bits vazios de rs1 são preenchidos com zero. O resultado é então escrito no registrador de destino (rd).

SLLI (Base RV32I)
- Shift Left Logical Immediate (Deslocamento Lógico à Esquerda do Imediato).
- Desloca o valor guardado no registrador de origem primário (rs1) à esquerda pelo número de posições indicado pelo shamt. Os bits vazios de rs1 são preenchidos com zero. O resultado é então escrito no registrador de destino (rd). Só é permitido quando o valor do bit mais significativo de shamt for igual a 0.

SRL (Base RV32I)
- Shift Right Logical (Deslocamento Lógico à Direita).
- Desloca o valor guardado no registrador de origem primário (rs1) à direita pelo número de posições indicado pelos 5 bits menos significativos do valor guardado no registrador de origem secundário (rs2). Os bits remanescentes de rs2 são ignorados. Os bits vazios de rs1 são preenchidos com zero. O resultado é então escrito no registrador de destino (rd).

SRLI (Base RV32I)
- Shift Right Logical Immediate (Deslocamento Lógico à Direita do Imediato).
- Desloca o valor guardado no registrador de origem primário (rs1) à direita pelo número de posições indicado pelo shamt. Os bits vazios de rs1 são preenchidos com zero. O resultado é então escrito no registrador de destino (rd). Só é permitido quando o valor do bit mais significativo de shamt for igual a 0.

SRA (Base RV32I) 
- Shift Right Arithmetic (Deslocamento Aritmético à Direita).
- Desloca o valor guardado no registrador de origem primário (rs1) à direita pelo número de posições indicado pelos 5 bits menos significativos do valor guardado no registrador de origem secundário (rs2). Os bits remanescentes de rs2 são ignorados. Os bits vazios de rs1 são preenchidos com o valor do bit mais significativo de rs1. O resultado é então escrito no registrador de destino (rd).

SRAI  (Base RV32I)
- Shift Right Arithmetic Immediate (Deslocamento Aritmético à Direita do Imediato).
- Desloca o valor guardado no registrador de origem primário (rs1) à direita pelo número de posições indicado pelo shamt. Os bits vazios de rs1 são preenchidos com cópias do bit mais significativo de rs1. O resultado é então escrito no registrador de destino (rd). Só é permitido quando o valor do bit mais significativo de shamt for igual a 0.

**Instruções Aritméticas**

ADD (Base RV32I)
- Add (Adição).
- Soma o valor armazenado no registrador de origem primário (rs1) com o valor armazenado no registrador de origem secundário (rs2) e armazena o resultado no registrador de destino (rd). Em caso de overflow, ele é ignorado.

ADDI (Base RV32I)
- Add Immediate (Adição do Imediato).
- Soma o valor armazenado no registrador de origem primário (rs1) com o sinal estendido do imediato e armazena o resultado no registrador de destino (rd). Em caso de overflow, ele é ignorado.

SUB (Base RV32I)
- Subtract (Subtração).
- Subtrai o valor armazenado no registrador de origem primário (rs1) pelo valor armazenado no registrador de origem secundário (rs2) e armazena o resultado no registrador de destino (rd). Em caso de overflow, ele é ignorado.

MUL (Extensão M)
- Multiply (Multiplicação).
- Multiplica o valor armazenado no registrador de origem primário (rs1) pelo valor armazenado no registrador de origem secundário (rs2) e armazena o resultado no registrador de destino (rd). Em caso de overflow, ele é ignorado.

MULH (Extensão M)
- Multiply High (Multiplicação Superior).
- Multiplica o valor armazenado no registrador de origem primário (rs1) pelo valor armazenado no registrador de origem secundário (rs2) considerando que são números de complemento de dois e armazena a metade superior do produto no registrador de destino (rd).

MULHSU (Extensão M)
- Multiply High Signed and Unsigned (Multiplicação Superior com Sinal e Sem Sinal).
- Multiplica o valor armazenado no registrador de origem primário (rs1) pelo valor armazenado no registrador de origem secundário (rs2), considerando que rs1 é um número de complemento de dois e rs2 é um número sem sinal, e armazena a metade superior do produto no registrador de destino (rd).

MULHU (Extensão M)
- Multiply High Unsigned (Multiplicação Superior Sem Sinal).
- Multiplica o valor armazenado no registrador de origem primário (rs1) pelo valor armazenado no registrador de origem secundário (rs2), considerando que ambos são números sem sinal, e armazena a metade superior do produto no registrador de destino (rd).

DIV (Extensão M)
- Divide (Divisão).
- Divide o valor armazenado no registrador de origem primário (rs1) pelo valor armazenado no registrador de origem secundário (rs2), considerando que são números de complemento de dois, arredondando para zero, e armazena o quociente no registrador de destino (rd).

DIVU (Extensão M)
- Divide Unsigned (Divisão Sem Sinal).
- Divide o valor armazenado no registrador de origem primário (rs1) pelo valor armazenado no registrador de origem secundário (rs2), considerando que são números sem sinal, arredondando para zero, e armazena o quociente no registrador de destino (rd). 

REM (Extensão M)
- Remainder (Resto).
- Divide o valor armazenado no registrador de origem primário (rs1) pelo valor armazenado no registrador de origem secundário (rs2), considerando que são números de complemento de dois, arredondando para zero, e armazena o resto no registrador de destino (rd). 

REMU (Extensão M)
- Remainder Unsigned (Resto Sem Sinal).
- Divide o valor armazenado no registrador de origem primário (rs1) pelo valor armazenado no registrador de origem secundário (rs2), considerando que são números sem sinal, arredondando para zero, e armazena o resto no registrador de destino (rd).

**Instruções Lógicas**

XOR (Base RV32I)
- Exclusive OR (OU Exclusivo).
- Realiza a operação lógica XOR, bit a bit, entre os valores armazenados nos registradores de origem primário (rs1) e secundário (rs2) e armazena o resultado no registrador de destino (rd).

XORI (Base RV32I)
- Exclusive OR Immediate (OU Exclusivo Imediato).
- Realiza a operação lógica XOR, bit a bit, entre o valor armazenado no registrador de origem primário (rs1) e o imediato com sinal estendido e armazena o resultado no registrador de destino (rd).

OR (Base RV32I)
- OR (OU).
- Realiza a operação lógica OR, bit a bit, entre os valores armazenados nos registradores de origem primário (rs1) e secundário (rs2) e armazena o resultado no registrador de destino (rd).

ORI (Base RV32I)
- OR Immediate (OU Imediato).
- Realiza a operação lógica OR, bit a bit, entre o valor armazenado no registrador de origem primário (rs1) e o imediato com sinal estendido e armazena o resultado no registrador de destino (rd).

AND (Base RV32I)
- AND (E).
- Realiza a operação lógica AND, bit a bit, entre os valores armazenados nos registradores de origem primário (rs1) e secundário (rs2) e armazena o resultado no registrador de destino (rd).

ANDI (Base RV32I)
- AND Immediate (E Imediato).
- Realiza a operação lógica AND, bit a bit, entre o valor armazenado no registrador de origem primário (rs1) e o imediato com sinal estendido e armazena o resultado no registrador de destino (rd).

**Instruções de Comparação**

SLT (Base RV32I)
- Set if Less Than (Definir se Menor que).
- Verifica se o valor armazenado no registrador de origem primário (rs1) é menor que o valor armazenado no registrador de origem secundário (rs2), considerando que são complemento de dois, em caso positivo, armazena 1 no registrador de destino (rd), caso contrário, armazena 0.

SLTI (Base RV32I)
- Set if Less Than Immediate (Definir se Menor que Imediato).
- Verifica se o valor armazenado no registrador de origem primário (rs1) é menor que o valor do imediato, considerando que são complemento de dois, em caso positivo, armazena 1 no registrador de destino (rd), caso contrário, armazena 0.

SLTU (Base RV32I)
- Set if Less Than Unsigned (Definir se Menor que Sem Sinal).
- Verifica se o valor armazenado no registrador de origem primário (rs1) é menor que o valor armazenado no registrador de origem secundário (rs2), considerando que são valores sem sinal, em caso positivo, armazena 1 no registrador de destino (rd), caso contrário, armazena 0.

SLTIU (Base RV32I)
- Set if Less Than Immediate Unisgned(Definir se Menor que Imediato Sem Sinal).
- Verifica se o valor armazenado no registrador de origem primário (rs1) é menor que o imediato com extensão de sinal, considerando que são valores sem sinal, em caso positivo, armazena 1 no registrador de destino (rd), caso contrário, armazena 0.

**Instruções de Desvio**

BEQ (Base RV32I)
- Branch if Equal (Desvio se Igual)
- Verifica se o valor armazenado no registrador de origem primário (rs1) é igual ao valor armazenado no registrador de origem secundário (rs2), em caso positivo, modifica o PC para o valor atual somado ao offset com extensão de sinal.

BNE (Base RV32I)
- Branch if Not Equal (Desvio se Não for Igual)
- Verifica se o valor armazenado no registrador de origem primário (rs1) é diferente do valor armazenado no registrador de origem secundário (rs2), em caso positivo, modifica o PC para o valor atual somado ao offset com extensão de sinal.

BLT (Base RV32I)
- Branch if Less Than (Desvio se for Menor Que)
- Verifica se o valor armazenado no registrador de origem primário (rs1) é menor que o valor armazenado no registrador de origem secundário (rs2), considerando que são números em complemento de dois, em caso positivo, modifica o PC para o valor atual somado ao offset com extensão de sinal.

BGE (Base RV32I)
- Branch if Greater than or Equal to (Desvio se for Maior Que ou Igual a)
- Verifica se o valor armazenado no registrador de origem primário (rs1) é maior ou igual ao valor armazenado no registrador de origem secundário (rs2), considerando que são números em complemento de dois, em caso positivo, modifica o PC para o valor atual somado ao offset com extensão de sinal.

BLTU (Base RV32I)
- Branch if Less Than Unsigned (Desvio se for Menor Que Sem Sinal)
- Verifica se o valor armazenado no registrador de origem primário (rs1) é menor que o valor armazenado no registrador de origem secundário (rs2), considerando que são números sem sinal, em caso positivo, modifica o PC para o valor atual somado ao offset com extensão de sinal.

BGEU (Base RV32I)
- Branch if Greater than or Equal to Unsigned (Desvio se for Maior Que ou Igual a Sem Sinal)
- Verifica se o valor armazenado no registrador de origem primário (rs1) é maior ou igual ao valor armazenado no registrador de origem secundário (rs2), considerando que são números sem sinal, em caso positivo, modifica o PC para o valor atual somado ao offset com extensão de sinal.

**Instruções de Conexão**

JAL (Base RV32I)
- Jump and Link (Salto e Conexão).
- Escreve o endereço da próxima instrução (PC+4) no registrador de destino (rd) e modifica o PC para o valor atual somado ao offset com extensão de sinal. Se rd for omitido, o valor de retorno é armazenado no registrador x1.

JALR (Base RV32I)
- Jump and Link Register (Salto e Conexão por Registrador).
- Realiza um cópia do PC para registrador de origem primário (rs1) + offset estendido, mascara o bit menos significativo do endereço resultante e armazena o endereço anterior de PC+4 no registrador de destino (rd). Se rd for omitido, o valor é armazenado no registrador x1.

**Instruções de Carregar**

LB (Base RV32I)
- Load Byte (Carrega Byte).
- Carrega um byte da memória no endereço do registrador de origem primário (rs1) + offset estendido e armazena o valor no registrador de destino (rd), com extensão de sinal.

LH (Base RV32I)
- Load Halfword (Carrega Halfword).
- Carrega dois bytes da memória no endereço do registrador de origem primário (rs1) + offset estendido e armazena o valor no registrador de destino (rd), com extensão de sinal.

LBU (Base RV32I)
- Load Byte Unsigned (Carrega Byte Sem Sinal).
- Carrega um byte da memória no endereço do registrador de origem primário (rs1) + offset estendido e armazena o valor no registrador de destino (rd), com extensão de zero.

LHU (Base RV32I)
- Load Halfword Unsigned (Carrega Halfword Sem Sinal).
- Carrega dois bytes da memória no endereço do registrador de origem primário (rs1) + offset estendido e armazena o valor no registrador de destino (rd), com extensão de zero.

LW (Base RV32I)
- Load Word (Carrega Word).
- Carrega quatro bytes da memória no endereço do registrador de origem primário (rs1) + offset estendido e armazena o valor no registrador de destino (rd).

**Instruções de Armazenamento**

SB (Base RV32I)
- Store Byte (Armazena Byte).
- Armazena o byte menos significativo do registrador de origem secundário (rs2)  na memória no endereço do registrador de origem primário (rs1) + offset estendido.

SH (Base RV32I)
- Store Halfword (Armazena Halfword).
- Armazena os dois bytes menos significativos do registrador de origem secundário (rs2)  na memória no endereço do registrador de origem primário (rs1) + offset estendido.

SW (Base RV32I)
- Store Word (Armazena Word).
- Armazena os quatro bytes menos significativos do registrador de origem secundário (rs2)  na memória no endereço do registrador de origem primário (rs1) + offset estendido.
