## 3. Resultados

Foi desenvolvido um ambiente de testes no GitHub Actions para a verificação de
cada módulo VHDL. Por meio dele também é possível verificar os _logs_ caso algo dê
errado e as etapas que são necessárias para execução da validação, sendo
possível ver um exemplo de teste bem sucedido na Figura 7.

**Figura 7** - 

::: danger TO DO

Figura 7

:::

Além do ambiente de testes foi criado um ambiente de desenvolvimento no Visual
Studio Code que permite executar os mesmos testes do GitHub actions, realizar a
análise e síntese, a análise e elaboração e executar Quartus com interface
gráfica através de botões na barra de status do editor de texto, mostrados na
Figura 8.

**Figura 8** - 

::: danger TO DO

Figura 8

:::

Os recursos desenvolvidos permitem que testes sejam realizados ao longo do
processo de desenvolvimento, garantindo que os componentes funcionem de maneira
adequada e trazem uma facilidade para o desenvolvedor, que não precisa instalar
todas as ferramentas manualmente, nem executar comandos no terminal. Até o
momento foi integrado o processador com pipeline (Figura 1, Escopo do Projeto),
com a implementação dos componentes (seção 3.1), módulos (seção 3.2) e etapas (seção 3.3) 
sendo realizada, assim como a validação dos componentes e módulos por
meio de testes automatizados, e a validação da integração por meio da
implementação das instruções do Conjunto Base dos Inteiros para arquiteturas de
32 _bits_.

### 3.1 Componentes Desenvolvidos

Os elementos do processador no nível mais baixo da hierarquia (seção 2).

#### 3.1.1 Somador (Genérico)

Componente que recebe dois vetores de entrada de múltiplos _bits_, quantidade de
_bits_ ajustável de acordo com a necessidade, e soma esses dois valores,
devolvendo na saída o resultado. Esse componente está ilustrado na Figura 9.

**Figura 9** - Diagrama de Portas do Componente Genérico Somador

::: danger TO DO

Componentes

:::

#### 3.1.2 Multiplexador de duas entradas (Genérico)

Componente que recebe dois vetores de entrada de múltiplos _bits_, quantidade de _bits_ ajustável de acordo com a necessidade, e recebe um seletor de 1 bit, e dependendo do valor do seletor, um dos valores de entrada passa a ser valor de saída. Esse componente está ilustrado na Figura 10.

**Figura 10** - Diagrama de Portas do Componente Genérico Multiplexador de duas entradas

::: danger TO DO

Componentes

:::

#### 3.1.3 Multiplexador de quatro entradas (Genérico)

Componente que recebe quatro vetores de entrada de múltiplos _bits_, quantidade de _bits_ ajustável de acordo com a necessidade, e recebe um seletor de 2 _bits_, e dependendo do valor do seletor, um dos valores de entrada passa a ser valor de saída. Esse componente está ilustrado na Figura 11.

**Figura 11** - Diagrama de Portas do Componente Genérico Multiplexador de quatro entradas

::: danger TO DO

Componentes

:::

#### 3.1.4 Memória ROM (Genérico)

Componente onde ficam armazenadas as instruções do programa a ser rodado no processador, recebe um vetor de endereço de múltiplos _bits_, e devolve na saída a instrução de múltiplos _bits_ armazenada nesse endereço. Esse componente está ilustrado na Figura 12.

**Figura 12** - Diagrama de Portas do Componente Genérico Memória ROM

::: danger TO DO

Componentes

:::

A memória ROM foi desenvolvida apenas para propósitos de validação da integração do processador, pois os integrantes da CTI mencionaram que usariam uma memória externa.

#### 3.1.5 Memória RAM (Genérico)

Componente que funciona com clock e depende de um sinal de ativação, armazena valores de múltiplos _bits_ recebidos na entrada, que é escrito na posição da memória apontada pelo endereço de múltiplos _bits_ recebido, dependendo do sinal de escrita, e devolve na saída o valor armazenado no mesmo endereço, dependendo do sinal de leitura. Esse componente está ilustrado na Figura 13.

**Figura 13** - Diagrama de Portas do Componente Genérico Memória RAM

::: danger TO DO

Componentes

:::

#### 3.1.6 Registrador (Genérico)

Componente que funciona com clock e armazena um vetor de múltiplos _bits_, que é recebido no vetor de entrada, de acordo com um sinal de ativação do registrador, devolvendo esse valor na saída, e caso o sinal de limpar esteja ativado, devolve um vetor de múltiplos zeros. Esse componente está ilustrado na Figura 14.

**Figura 14** - Diagrama de Portas do Componente Genérico Registrador

::: danger TO DO

Componentes

:::

#### 3.1.7 Comparador (Genérico)

Componente que recebe dois vetores de 32 bit e devolve três flags, uma que indica se ambos os vetores são iguais, outra que indica se o vetor de entrada primário é menor do que o secundário, e a última indica se o vetor primário é maior ou igual ao secundário. Esse componente está ilustrado na Figura 15.

**Figura 15** - Diagrama de Portas do Componente Genérico Comparador

::: danger TO DO

Componentes

:::

#### 3.1.8 Deslocador da ULA (Específico)

Componente que recebe uma instrução de 32 _bits_ e desloca os _bits_ para a direita ou para a esquerda, preenchendo os espaços vazios com 0, ou no caso dos deslocamentos aritméticos, com extensão de sinal. Esse componente está ilustrado na Figura 16.

**Figura 16** - Diagrama de Portas do Componente Específico Deslocador da ULA

::: danger TO DO

Componentes

:::

#### 3.1.9 Unidade Lógica e Aritmética (Específico)

Componente que recebe dois vetores de entrada de 32 _bits_, e realiza operações entre elas, devolvendo o resultado na saída. Para realizar as operações, o componente recebe dois sinais de inversão, um para cada vetor de entrada, e um seletor de 2 _bits_ para decidir qual operação será realizada. Esse componente está ilustrado na Figura 17.

**Figura 17** - Diagrama de Portas do Componente Específico Unidade Lógica e Aritmética

::: danger TO DO

Componentes

:::

É preciso comentar que a ULA usa de um componente separado, a ULA BIT, que realiza as operações da ULA em um bit, sendo usado esse componente na ULA para cada um dos _bits_ dos vetores de entrada, estando interligados entre si para passagem de valor de _carry_,  _overflow_ e slt. Esse componente está ilustrado na Figura 18.

**Figura 18** - Diagrama de Portas do Subcomponente Específico ULA Bit

::: danger TO DO

Componentes

:::

#### 3.1.10 Unidade de Controle da ULA (Específico)

Componente que recebe o opcode e as funções da instrução sendo executada, e devolve na saída um vetor de 4 _bits_ para entrar na ULA, sendo os dois _bits_ mais significativos os sinais de inversão, e os dois menos significativos o seletor. Esse componente está ilustrado na Figura 19.

**Figura 19** - Diagrama de Portas do Componente Específico Unidade de Controle da ULA

::: danger TO DO

Componentes

:::

#### 3.1.11 Banco de Registradores (Específico)

Componente que funciona com clock e sinal de ativação, recebe três endereços de 5 _bits_, que apontam para 3 registradores do banco, e um vetor de 32 _bits_ a ser escrito em um dos endereços, e devolve dois vetores de 32 _bits_ que estavam guardados nos registradores apontados pelos outros dois endereços. Esse componente está ilustrado na Figura 20.

**Figura 20** - Diagrama de Portas do Componente Específico Banco de Registradores

::: danger TO DO

Componentes

:::

#### 3.1.12 Unidade de Encaminhamento de Dados para Execução (CPU)

Componente que encaminha dados das etapas MEM e WB (seção 2) para a etapa EX (seção 2), 
para resolver um _hazzard_ de dado. Esse componente está ilustrado na Figura 21.

**Figura 21** - Diagrama de Portas do Componente de CPU Unidade de Encaminhamento de Dados para Execução

::: danger TO DO

Componentes

:::

#### 3.1.13 Extensor de _bits_ para STORE (CPU)

Componente que recebe um vetor de 32 _bits_ do Banco de Registradores e, dependendo de qual instrução do tipo STORE estiver sendo usada, devolve na saída ou o vetor inteiro, ou parte dele com extensão de zeros. Esse componente está ilustrado na Figura 22.

**Figura 22** - Diagrama de Portas do Componente de CPU Extensor de _bits_ para STORE

::: danger TO DO

Componentes

:::

#### 3.1.14 Extensor de Sinal para LOAD (CPU)

Componente que recebe um vetor de 32 _bits_ da memória RAM e, dependendo de qual instrução do tipo LOAD estiver sendo usada, devolve na saída ou o vetor inteiro, ou parte dele com extensão de zeros ou extensão de sinal. Esse componente está ilustrado na Figura 23.

**Figura 23** - Diagrama de Portas do Componente de CPU Extensor de Sinal para LOAD

::: danger TO DO

Componentes

:::

### 3.2 Módulos Desenvolvidos

#### 3.2.1 Módulo Controlador da Unidade de Execução

Módulo que implementa a Unidade de Controle da ULA. Esse módulo está ilustrado na Figura 24.

**Figura 24** - Diagrama de Portas do Módulo Controlador da Unidade de Execução

::: danger TO DO

Componentes

:::

#### 3.2.2 Módulo Unidade de Execução

Módulo que implementa a ULA. Esse módulo está ilustrado na Figura 25.

**Figura 25** - Diagrama de Portas do Módulo Unidade de Execução

::: danger TO DO

Componentes

:::

#### 3.2.3 Módulo Unidade de Controle

Módulo que recebe a instrução de 32 _bits_ vinda da memória e devolve o imediato e os sinais de controle. Este módulo acabou por ser o único módulo que ao invés de implementar um componente com lógica próprio, implementa a lógica por si só, já que é o módulo responsável por mapear a lógica do ISA do RISC-V em pontos de controle e imediato. Esse módulo está ilustrado na Figura 26.

**Figura 26** - Diagrama de Portas do Módulo Unidade de Controle

::: danger TO DO

Componentes

:::

#### 3.2.4 Módulo Contador de Programa

Módulo que implementa o Contador de Programa, que é um Registrador Genérico. Esse módulo está ilustrado na Figura 27.

**Figura 27** - Diagrama de Portas do Módulo Contador de Programa

::: danger TO DO

Componentes

:::

#### 3.2.5 Módulo Banco de Registradores
	
Módulo que implementa o Banco de Registradores. Esse módulo está ilustrado na Figura 28.

**Figura 28** - Diagrama de Portas do Módulo Banco de Registradores

::: danger TO DO

Componentes

:::

#### 3.2.6 Módulo Escrita no Retorno

Módulo que implementa o multiplexador de escrita no banco de registradores. Esse módulo está ilustrado na Figura 29.

**Figura 29** - Diagrama de Portas do Módulo Escrita no Retorno

::: danger TO DO

Componentes

:::

#### 3.2.7 Módulo Comparação para Desvio

Módulo que implementa o comparador. Esse módulo está ilustrado na Figura 30.

**Figura 30** - Diagrama de Portas do Módulo Comparação para Desvio

::: danger TO DO

Componentes

:::

#### 3.2.8 Módulo Desvio

Módulo que implementa a lógica que determina o endereço de destino de uma instrução de desvio. Esse módulo está ilustrado na Figura 31.

**Figura 31** - Diagrama de Portas do Módulo Desvio

::: danger TO DO

Componentes

:::

### 3.3 Etapas Desenvolvidas

#### 3.3.1 Etapa IF
	
A Etapa de Busca de Instrução é responsável por definir a próxima instrução a ser executada pelo processador. Nesta etapa, foi implementado somente o módulo Contador de Programa, uma vez que o cliente planeja usar uma memória externa no lugar da memória ROM, que não está implementada dentro da CPU. Esta é a única etapa que não tem função de registrador. Essa etapa está ilustrada na Figura 32.

**Figura 32** - Diagrama de Portas da Etapa IF

::: danger TO DO

Componentes

:::

#### 3.3.2 Etapa ID
	
A Etapa de Decodificação de Instrução é responsável por interpretar o que será executado e definir os sinais de controle. Nesta etapa, foram implementados os módulos Unidade de Controle, Desvio, Banco de Registradores e Comparação para Desvio. Essa etapa está ilustrada na Figura 33.

**Figura 33** - Diagrama de Portas da Etapa ID

::: danger TO DO

Componentes

:::

#### 3.3.3 Etapa EX
	
A Etapa de Execução é onde se realizam as operações do processador. Nesta etapa, foram implementados os módulos Controlador da Unidade de Execução, Unidade de Execução e Unidade Encaminhamento de Dados para Execução. Essa etapa está ilustrada na Figura 34.

**Figura 34** - Diagrama de Portas da Etapa EX

::: danger TO DO

Componentes

:::

#### 3.3.4 Etapa MEM
	
A Etapa de Acesso à Memória é responsável por guardar valores ou usar valores nos endereços da memória RAM. No entanto, como a memória RAM será externa, de acordo com a vontade do cliente, a mesma só tem os componentes Extensor de _bits_ para STORE e Extensor de Sinal para LOAD implementados. Essa etapa está ilustrada na Figura 35.

**Figura 35** - Diagrama de Portas da Etapa MEM

::: danger TO DO

Componentes

:::

#### 3.3.5 Etapa WB
	
A Etapa de Escrita no Retorno é onde o resultado da operação do processador ou o valor acessado na memória RAM sai para ser escrito no Banco de Registradores. É nesta etapa que se implementa o módulo Escrita no Retorno. Essa etapa está ilustrada na Figura 36.

**Figura 36** - Diagrama de Portas da Etapa WB

::: danger TO DO

Componentes

:::

Os testes automatizados foram realizados usando o cocotb, que permite simular
elementos VHDL, definir valores de entrada para os mesmos e conferir se a saída
é a esperada. Por exemplo, para testar o somador, seriam definidos dois valores,
um para cada uma das suas entradas (2 e 6 em binário de 32 _bits_, por exemplo), e
se checaria se o valor da saída é o esperado (8 em binário de 32 _bits_, se as
entradas forem 6 e 2).

Também se necessita mencionar que para facilitar o desenvolvimento, e com
permissão dos clientes, usou-se de uma estrutura de dados conhecida como
registro (record) para simplificar a passagem de sinal entre etapas, facilitando
assim a compreensão da arquitetura no nível superior. Estudar apêndice A para
melhor entender os registros feitos.

Por fim, documentou-se o projeto em um website cujo link está nas referências (DIAS, L. F.; RUGGIERO, G. V.;
SEIXAS, T. V., 2024) e que está ilustrado na Figura 37, hospedado no GitHub Pages utilizando de VitePress, uma
ferramenta que gera sites estáticos por meio de arquivos Markdown.

**Figura 37** - Página inicial do site de documentação (DIAS, L. F.; RUGGIERO, G. V.; SEIXAS, T. V., 2024)

::: danger TO DO

Screenshot

:::
