## 3. Resultados

Foi desenvolvido um ambiente de testes no GitHub Actions para a verificação de
cada módulo VHDL. Por meio dele também é possível verificar os _logs_ caso algo dê
errado e as etapas que são necessárias para execução da validação, sendo
possível ver um exemplo de teste bem sucedido na Figura 7.

**Figura 7** - 

::: danger TO DO

Figura 7

:::

Além do ambiente de testes foi criado um ambiente de desenvolvimento no Visual
Studio Code que permite executar os mesmos testes do GitHub actions, realizar a
análise e síntese, a análise e elaboração e executar Quartus com interface
gráfica através de botões na barra de status do editor de texto, mostrados na
Figura 8.

**Figura 8** - 

::: danger TO DO

Figura 8

:::

Os recursos desenvolvidos permitem que testes sejam realizados ao longo do
processo de desenvolvimento, garantindo que os componentes funcionem de maneira
adequada e trazem uma facilidade para o desenvolvedor, que não precisa instalar
todas as ferramentas manualmente, nem executar comandos no terminal. Até o
momento foi integrado o processador com pipeline (Figura 1, Escopo do Projeto),
com a implementação dos componentes (ver Seção 3.1), módulos (ver Seção 3.2) e etapas (ver Seção 3.3) 
sendo realizada, assim como a validação dos componentes e módulos por
meio de testes automatizados, e a validação da integração por meio de
testes das instruções do Conjunto Base dos Inteiros para arquiteturas de
32 _bits_.

### 3.1 Nível dos Componentes Desenvolvidos

O nível que contém os elementos do processador que se encontram na base da hierarquia (ver Seção 2). Eles estão classificados
como componentes genéricos, que são componentes que poderiam ser aplicados em outros projetos sem modificação
devido ao fato de serem genéricos, componentes RV32I, que são componentes desenvolvidos para atender às 
especificações de um processador RV32I.

#### 3.1.1 Somador (Genérico)

Componente que recebe dois vetores de entrada de múltiplos _bits_, quantidade de
_bits_ ajustável de acordo com a necessidade, e soma esses dois valores,
devolvendo na saída o resultado. Esse componente está ilustrado na Figura 9.

![Somador Genérico](../public/images/reference/report_components/generic_adder.drawio.svg)
**Figura 9** - Topologia do Componente Genérico Somador

#### 3.1.2 Multiplexador de duas entradas (Genérico)

Componente que recebe dois vetores de entrada de múltiplos _bits_, quantidade de _bits_ ajustável de acordo com a 
necessidade, e recebe um seletor de 1 _bit_, e dependendo do valor do seletor, um dos valores de entrada passa a ser valor de 
saída. Esse componente está ilustrado na Figura 10.

![MUX 2x1](../public/images/reference/report_components/generic_mux_2x1.drawio.svg)
**Figura 10** - Topologia do Componente Genérico Multiplexador de duas entradas

#### 3.1.3 Multiplexador de quatro entradas (Genérico)

Componente que recebe quatro vetores de entrada de múltiplos _bits_, quantidade de _bits_ ajustável de acordo com a 
necessidade, e recebe um seletor de 2 _bits_, e dependendo do valor do seletor, um dos valores de entrada passa a ser valor 
de saída. Esse componente está ilustrado na Figura 11.

![MUX 4x1](../public/images/reference/report_components/generic_mux_4x1.drawio.svg)
**Figura 11** - Topologia do Componente Genérico Multiplexador de quatro entradas

#### 3.1.4 Memória ROM (Genérico)

Componente onde ficam armazenadas as instruções do programa a ser rodado no processador, recebe um vetor de endereço de 
múltiplos _bits_, e devolve na saída a instrução de múltiplos _bits_ armazenada nesse endereço. Esse componente está 
ilustrado na Figura 12.

![ROM](../public/images/reference/report_components/generic_rom.drawio.svg)
**Figura 12** - Topologia do Componente Genérico Memória ROM

A memória ROM foi desenvolvida apenas para propósitos de validação da integração do processador, pois os integrantes da CTI 
mencionaram que usariam uma memória externa.

#### 3.1.5 Memória RAM (Genérico)

Componente que funciona com clock e depende de um sinal de ativação, armazena valores de múltiplos _bits_ recebidos na 
entrada, que é escrito na posição da memória apontada pelo endereço de múltiplos _bits_ recebido, dependendo do sinal de 
escrita, e devolve na saída o valor armazenado no mesmo endereço, dependendo do sinal de leitura. Esse componente está 
ilustrado na Figura 13.

![RAM](../public/images/reference/report_components/generic_ram.drawio.svg)
**Figura 13** - Topologia do Componente Genérico Memória RAM

#### 3.1.6 Registrador (Genérico)

Componente que funciona com clock e armazena um vetor de múltiplos _bits_, que é recebido no vetor de entrada, de acordo com 
um sinal de ativação do registrador, devolvendo esse valor na saída, e caso o sinal de limpar esteja ativado, devolve um 
vetor de múltiplos zeros. Esse componente está ilustrado na Figura 14.

![Registrador Genérico](../public/images/reference/report_components/generic_register.drawio.svg)
**Figura 14** - Topologia do Componente Genérico Registrador

#### 3.1.7 Comparador (Genérico)

Componente que recebe dois vetores de 32 _bit_ e devolve três flags, uma que indica se ambos os vetores são iguais, outra que 
indica se o vetor de entrada primário é menor do que o secundário, e a última indica se o vetor primário é maior ou igual ao 
secundário. Esse componente está ilustrado na Figura 15.

![alt text](../public/images/reference/report_components/generic_comparator.drawio.svg)
**Figura 15** - Topologia do Componente Genérico Comparador

#### 3.1.8 Deslocador da ULA (RV32I)

Componente que recebe uma instrução de 32 _bits_ e desloca os _bits_ para a direita ou para a esquerda, preenchendo os 
espaços vazios com 0, ou no caso dos deslocamentos aritméticos, com extensão de sinal. Esse componente está ilustrado na 
Figura 16.

![alt text](../public/images/reference/report_components/rv32i_alu_shifter.drawio.svg)
**Figura 16** - Topologia do Componente RV32I Deslocador da ULA

#### 3.1.9 Unidade Lógica e Aritmética (RV32I)

Componente que recebe dois vetores de entrada de 32 _bits_, e realiza operações entre elas, devolvendo o resultado na saída. 
Para realizar as operações, o componente recebe dois sinais de inversão, um para cada vetor de entrada, e um seletor de 2 
_bits_ para decidir qual operação será realizada. Esse componente está ilustrado na Figura 17.

![alt text](../public/images/reference/report_components/rv32i_alu.drawio.svg)
**Figura 17** - Topologia do Componente RV32I Unidade Lógica e Aritmética

É preciso comentar que a ULA usa de um componente separado, a ULA _bit_, que realiza as operações da ULA em um _bit_, sendo 
usado esse componente na ULA para cada um dos _bits_ dos vetores de entrada, estando interligados entre si para passagem de 
valor de _carry_,  _overflow_ e slt. Esse componente está ilustrado na Figura 18.

![alt text](../public/images/reference/report_components/rv32i_alu_bit.drawio.svg)
**Figura 18** - Topologia do Subcomponente RV32I ULA _bit_

#### 3.1.10 Unidade de Controle da ULA (RV32I)

Componente que recebe o opcode e as funções da instrução sendo executada, e devolve na saída um vetor de 4 _bits_ para entrar 
na ULA, sendo os dois _bits_ mais significativos os sinais de inversão, e os dois menos significativos o seletor. Esse 
componente está ilustrado na Figura 19.

![alt text](../public/images/reference/report_components/rv32i_alu_controller.drawio.svg)
**Figura 19** - Topologia do Componente RV32I Unidade de Controle da ULA

#### 3.1.11 Banco de Registradores (RV32I)

Componente que funciona com clock e sinal de ativação, recebe três endereços de 5 _bits_, que apontam para 3 registradores do 
banco, e um vetor de 32 _bits_ a ser escrito em um dos endereços, e devolve dois vetores de 32 _bits_ que estavam guardados 
nos registradores apontados pelos outros dois endereços. Esse componente está ilustrado na Figura 20.

![alt text](../public/images/reference/report_components/rv32i_register_file.drawio.svg)
**Figura 20** - Topologia do Componente RV32I Banco de Registradores

#### 3.1.12 Controlador de Desvio (RV32I)

Componente que recebe duas flags de sinal, que indicam se cada um dos vetores de dados que foram comparados no comparador
têm sinal, e três flags que indicam se o vetor de dados 1 é maior, igual ou menor ao vetor de dados 2. O componente também 
recebe a função da instrução, para saber se o resultado da comparação gera condição de desvio, e isso é indicado pelo sinal 
de saída. Esse componente está ilustrado na Figura 21.

![alt text](../public/images/reference/report_components/rv32i_branch_controller.drawio.svg)
**Figura 21** - Topologia do Componente RV32I Controlador de Desvio

### 3.2 Nível dos Módulos Desenvolvidos

#### 3.2.1 Módulo Controlador da Unidade de Execução

Módulo que implementa a Unidade de Controle da ULA. Esse módulo está ilustrado na Figura 22.

![Módulo Controlador da Unidade de Execução](../public/images/reference/report_components/module_execution_unit_controller.drawio.svg)
**Figura 22** - Topologia do Módulo Controlador da Unidade de Execução

#### 3.2.2 Módulo Unidade de Execução

Módulo que implementa a ULA. Esse módulo está ilustrado na Figura 23.

![Módulo Unidade de Execução](../public/images/reference/report_components/module_execution_unit.drawio.svg)
**Figura 23** - Topologia do Módulo Unidade de Execução

#### 3.2.3 Módulo Unidade de Controle

Módulo que recebe a instrução de 32 _bits_ vinda da memória e devolve o imediato e os sinais de controle. Este módulo acabou 
por ser o único módulo que ao invés de implementar um componente com lógica próprio, implementa a lógica por si só, já que é 
o módulo responsável por mapear a lógica do ISA do RISC-V em pontos de controle e imediato. Esse módulo está ilustrado na 
Figura 24.

![Módulo Unidade de Controle](../public/images/reference/report_components/module_control_unit.drawio.svg)
**Figura 24** - Topologia do Módulo Unidade de Controle

#### 3.2.4 Módulo Contador de Programa

Módulo que implementa o Contador de Programa, que é um Registrador Genérico. Esse módulo está ilustrado na Figura 25.

![Módulo Contador de Programa](../public/images/reference/report_components/module_program_counter.drawio.svg)
**Figura 25** - Topologia do Módulo Contador de Programa

#### 3.2.5 Módulo Banco de Registradores
	
Módulo que implementa o Banco de Registradores. Esse módulo está ilustrado na Figura 26.

![Módulo Banco de Registradores](../public/images/reference/report_components/module_register_file.drawio.svg)
**Figura 26** - Topologia do Módulo Banco de Registradores

#### 3.2.6 Módulo Escrita no Retorno

Módulo que implementa o multiplexador de escrita no banco de registradores. Esse módulo está ilustrado na Figura 27.

![Módulo Escrita no Retorno](../public/images/reference/report_components/module_write_back.drawio.svg)
**Figura 27** - Topologia do Módulo Escrita no Retorno

#### 3.2.7 Módulo Comparação para Desvio

Módulo que implementa o comparador. Esse módulo está ilustrado na Figura 28.

![Módulo Comparação para Desvio](../public/images/reference/report_components/module_branch_compare_unit.drawio.svg)
**Figura 28** - Topologia do Módulo Comparação para Desvio

#### 3.2.8 Módulo Desvio

Módulo que implementa a lógica que determina o endereço de destino de uma instrução de desvio. 
Esse módulo está ilustrado na Figura 29.

![Módulo Desvio](../public/images/reference/report_components/module_branch_unit.drawio.svg)
**Figura 29** - Topologia do Módulo Desvio

### 3.3 Nível da CPU desenvolvida

O nível mais alto da hierarquia (ver Seção 2), onde estão implementadas as etapas da _pipeline_ do 
processador, o _top level_ (visão geral) do mesmo, e os elementos que implementam solução de _hazards_ 
inerentes ao processador, tanto _hazards_ de controle quanto de dados.

#### 3.3.1 Etapa IF
	
A Etapa de Busca de Instrução é responsável por definir a próxima instrução a ser executada pelo processador. Nesta etapa, 
foi implementado somente o módulo Contador de Programa, uma vez que o cliente planeja usar uma memória externa no lugar da 
memória ROM, que não está implementada dentro da CPU. Esta é a única etapa que não tem função de registrador. Essa etapa está 
ilustrada na Figura 30.

![Etapa IF](../public/images/reference/report_components/stage_if.drawio.svg)
**Figura 30** - Topologia da Etapa IF

#### 3.3.2 Etapa ID
	
A Etapa de Decodificação de Instrução é responsável por interpretar o que será executado e definir os sinais de controle. 
Nesta etapa, foram implementados os módulos Unidade de Controle, Desvio, Banco de Registradores e Comparação para Desvio. 
Essa etapa está ilustrada na Figura 31.

![Etapa ID](../public/images/reference/report_components/stage_id.drawio.svg)
**Figura 31** - Topologia da Etapa ID

#### 3.3.3 Etapa EX
	
A Etapa de Execução é onde se realizam as operações do processador. Nesta etapa, foram implementados os módulos Controlador 
da Unidade de Execução, Unidade de Execução e Unidade Encaminhamento de Dados para Execução. Essa etapa está ilustrada na 
Figura 32.

![Etapa EX](../public/images/reference/report_components/stage_ex.drawio.svg)
**Figura 32** - Topologia da Etapa EX

#### 3.3.4 Etapa MEM
	
A Etapa de Acesso à Memória é responsável por guardar valores ou usar valores nos endereços da memória RAM. No entanto, como 
a memória RAM será externa, de acordo com a vontade do cliente, a mesma só tem os componentes Extensor de _bits_ para STORE e 
Extensor de Sinal para LOAD implementados. Essa etapa está ilustrada na Figura 33.

![Etapa MEM](../public/images/reference/report_components/stage_mem.drawio.svg)
**Figura 33** - Topologia da Etapa MEM

#### 3.3.5 Etapa WB
	
A Etapa de Escrita no Retorno é onde o resultado da operação do processador ou o valor acessado na memória RAM sai para ser 
escrito no Banco de Registradores. É nesta etapa que se implementa o módulo Escrita no Retorno. Essa etapa está ilustrada na 
Figura 34.

![Etapa WB](../public/images/reference/report_components/stage_wb.drawio.svg)
**Figura 34** - Topologia da Etapa WB

#### 3.1.13 Unidade de Encaminhamento de Dados para Execução (CPU)

Componente que encaminha dados das etapas MEM e WB (ver Seção 2) para a etapa EX (ver Seção 2), 
para resolver um _hazard_ de dado. Esse componente está ilustrado na Figura 35.

![alt text](../public/images/reference/report_components/cpu_execution_forwarding_unit.drawio.svg)
**Figura 35** - Topologia do Componente de CPU Unidade de Encaminhamento de Dados para Execução

#### 3.1.14 Unidade de Encaminhamento de Dados para Desvio (CPU)

Componente que encaminha dados da etapa MEM (ver Seção 2) para a etapa ID (ver Seção 2), para resolver um _hazard_ de
dado. Esse componente está ilustrado na Figura 36.

![alt text](../public/images/reference/report_components/cpu_branch_forwarding_unit.drawio.svg)
**Figura 36** - Topologia do Componente de CPU Unidade de Encaminhamento de Dados para Desvio

#### 3.1.15 Unidade de Controle de Hazard (CPU)

Componente que responsável por solucionar  _hazards_ de controle que existem no processador. Esse componente
está ilustrado na Figura 37.

![alt text](../public/images/reference/report_components/cpu_hazard_control_unit.drawio.svg)
**Figura 37** - Topologia do Componente de CPU Unidade de Controle de Hazard

Os testes automatizados foram realizados usando o cocotb, que permite simular
elementos VHDL, definir valores de entrada para os mesmos e conferir se a saída
é a esperada. Por exemplo, para testar o somador, seriam definidos dois valores,
um para cada uma das suas entradas (2 e 6 em binário de 32 _bits_, por exemplo), e
se checaria se o valor da saída é o esperado (8 em binário de 32 _bits_, se as
entradas forem 6 e 2).

Também se necessita mencionar que para facilitar o desenvolvimento, e com
permissão dos clientes, usou-se de uma estrutura de dados conhecida como
registro (record) para simplificar a passagem de sinal entre etapas, facilitando
assim a compreensão da arquitetura no nível superior. Estudar apêndice A para
melhor entender os registros feitos.

Por fim, documentou-se o projeto em um website cujo link está nas referências (DIAS, L. F.; RUGGIERO, G. V.;
SEIXAS, T. V., 2024) e que está ilustrado na Figura 38, hospedado no GitHub Pages utilizando de VitePress, uma
ferramenta que gera sites estáticos por meio de arquivos Markdown.

![RISC-V Website](../public/images/reference/report_components/website.png)
**Figura 38** - Página inicial do site de documentação (DIAS, L. F.; RUGGIERO, G. V.; SEIXAS, T. V., 2024)
